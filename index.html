
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DTS JSON Viewer | Interactive JSON Schema Tree Visualization</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 0;
            color: #333;
        }

        .header {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
            padding: 24px 32px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
        }

        .header-content {
            max-width: 1400px;
            margin: 0 auto;
            display: flex;
            align-items: center;
            justify-content: space-between;
            flex-wrap: wrap;
            gap: 20px;
        }

        .logo {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .logo-icon {
            width: 48px;
            height: 48px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: 700;
            font-size: 20px;
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }

        .logo-text {
            display: flex;
            flex-direction: column;
        }

        .logo-text h1 {
            font-size: 28px;
            font-weight: 700;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            letter-spacing: -0.5px;
        }

        .logo-text .tagline {
            font-size: 13px;
            color: #666;
            font-weight: 500;
            margin-top: -2px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 32px;
        }

        .upload-section {
            background: white;
            border-radius: 16px;
            padding: 32px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            margin-bottom: 24px;
        }

        .upload-section h2 {
            font-size: 20px;
            font-weight: 600;
            color: #333;
            margin-bottom: 16px;
        }

        .upload-section p {
            color: #666;
            font-size: 14px;
            margin-bottom: 20px;
            line-height: 1.6;
        }

        #dropZone {
            border: 3px dashed #667eea;
            padding: 40px;
            border-radius: 12px;
            text-align: center;
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.05) 0%, rgba(118, 75, 162, 0.05) 100%);
            transition: all 0.3s ease;
            cursor: pointer;
        }

        #dropZone:hover {
            border-color: #764ba2;
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.1) 0%, rgba(118, 75, 162, 0.1) 100%);
            transform: translateY(-2px);
            box-shadow: 0 8px 24px rgba(102, 126, 234, 0.2);
        }

        #dropZone.dragover {
            border-color: #764ba2;
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.15) 0%, rgba(118, 75, 162, 0.15) 100%);
            transform: scale(1.02);
        }

        .drop-icon {
            font-size: 48px;
            margin-bottom: 16px;
        }

        #dropZone strong {
            display: block;
            font-size: 18px;
            color: #667eea;
            font-weight: 600;
            margin-bottom: 8px;
        }

        #dropZone code {
            background: rgba(102, 126, 234, 0.1);
            padding: 4px 8px;
            border-radius: 6px;
            color: #667eea;
            font-weight: 600;
            font-size: 14px;
        }

        #fileInput {
            margin-top: 20px;
            padding: 12px 24px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            font-size: 14px;
            transition: all 0.3s ease;
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }

        #fileInput:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.5);
        }

        #status {
            margin-top: 16px;
            font-size: 13px;
            color: #666;
            font-weight: 500;
        }

        #status.success {
            color: #10b981;
            font-weight: 600;
        }

        #status.error {
            color: #ef4444;
            font-weight: 600;
        }

        .tree-container {
            background: white;
            border-radius: 16px;
            padding: 24px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            overflow: auto;
            position: relative;
        }

        svg {
            border: none;
            background: transparent;
        }

        .node circle {
            fill: #fff;
            stroke: #667eea;
            stroke-width: 3px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .node circle:hover {
            stroke: #764ba2;
            stroke-width: 4px;
            r: 8;
        }

        .node circle.expandable {
            fill: #667eea;
        }

        .node text {
            font: 13px 'Inter', sans-serif;
            font-weight: 500;
            fill: #333;
            pointer-events: none;
        }

        .link {
            fill: none;
            stroke: #cbd5e1;
            stroke-width: 2px;
            transition: stroke 0.2s ease;
        }

        .link:hover {
            stroke: #667eea;
        }

        .instructions {
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.1) 0%, rgba(118, 75, 162, 0.1) 100%);
            border-left: 4px solid #667eea;
            padding: 16px 20px;
            border-radius: 8px;
            margin-top: 20px;
        }

        .instructions h3 {
            font-size: 14px;
            font-weight: 600;
            color: #667eea;
            margin-bottom: 8px;
        }

        .instructions ul {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        .instructions li {
            font-size: 13px;
            color: #666;
            margin-bottom: 6px;
            padding-left: 20px;
            position: relative;
        }

        .instructions li:before {
            content: "‚Üí";
            position: absolute;
            left: 0;
            color: #667eea;
            font-weight: 600;
        }

        @media (max-width: 768px) {
            .header-content {
                flex-direction: column;
                align-items: flex-start;
            }

            .container {
                padding: 16px;
            }

            .upload-section {
                padding: 20px;
            }

            #dropZone {
                padding: 24px;
            }
        }
    </style>
</head>
<body>
    <header class="header">
        <div class="header-content">
            <div class="logo">
                <div class="logo-icon">DTS</div>
                <div class="logo-text">
                    <h1>DTS JSON Viewer</h1>
                    <span class="tagline">Interactive Schema Visualization</span>
                </div>
            </div>
        </div>
    </header>

    <div class="container">
        <div class="upload-section">
            <h2>Upload JSON File</h2>
            <p>Visualize your JSON schema structure as an interactive, collapsible tree diagram. Supports files up to 1GB.</p>
            
            <div id="dropZone">
                <div class="drop-icon">üìÅ</div>
                <strong>Drag &amp; drop</strong> a <code>.json</code> file here, or choose a file:
                <br><br>
                <input type="file" id="fileInput" accept=".json">
                <div id="status">Max size: 1GB</div>
            </div>

            <div class="instructions">
                <h3>How to use:</h3>
                <ul>
                    <li>Click nodes to expand/collapse branches</li>
                    <li>Use mouse scroll to zoom in/out</li>
                    <li>Click and drag to pan around the tree</li>
                    <li>Green nodes indicate expandable branches</li>
                </ul>
            </div>
        </div>

        <div class="tree-container">
            <svg width="2000" height="2000"></svg>
        </div>
    </div>

    <script>
        const MAX_SIZE_BYTES = 1 * 1024 * 1024 * 1024; // 1GB max upload

        const fileInput = document.getElementById('fileInput');
        const dropZone = document.getElementById('dropZone');
        const statusEl = document.getElementById('status');

        const svg = d3.select("svg"),
              width = +svg.attr("width"),
              height = +svg.attr("height");

        const g = svg.append("g").attr("transform", "translate(50,50)");

        const zoom = d3.zoom()
            .scaleExtent([0.5, 3])
            .on("zoom", (event) => g.attr("transform", event.transform));

        svg.call(zoom);

        // Use nodeSize for better control over spacing
        // First value is vertical spacing (between siblings), second is horizontal spacing (between levels)
        const treeLayout = d3.tree()
            .nodeSize([120, 300]) // 120px vertical spacing between siblings, 300px horizontal spacing between levels
            .separation((a, b) => {
                // Additional separation between siblings - ensures nodes are well-spaced
                return (a.parent === b.parent ? 1.2 : 1);
            });
        let i = 0;

        // Store original JSON data for lazy loading
        let originalJsonData = null;

        // Shared loader for both file input and drag & drop
        function handleFile(file) {
            if (!file) return;

            if (file.size > MAX_SIZE_BYTES) {
                alert("File is too large. Maximum allowed size is 1GB.");
                statusEl.textContent = "‚ùå File too large. Max size is 1GB.";
                statusEl.className = "error";
                return;
            }

            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    originalJsonData = JSON.parse(e.target.result);
                    const schemaTree = buildTreeLazy(originalJsonData, "root");
                    renderTree(schemaTree);
                    statusEl.textContent = `‚úÖ Loaded: ${file.name} (${(file.size / 1024).toFixed(1)} KB)`;
                    statusEl.className = "success";
                } catch (error) {
                    alert("Invalid JSON file. Please upload a valid JSON.");
                    statusEl.textContent = "‚ùå Invalid JSON file.";
                    statusEl.className = "error";
                }
            };
            reader.readAsText(file);
        }

        // Input change handler
        fileInput.addEventListener('change', (event) => {
            const file = event.target.files[0];
            handleFile(file);
        });

        // Drag & drop handlers
        ;['dragenter', 'dragover'].forEach(evtName => {
            dropZone.addEventListener(evtName, (e) => {
                e.preventDefault();
                e.stopPropagation();
                dropZone.classList.add('dragover');
            });
        });

        ;['dragleave', 'dragend', 'drop'].forEach(evtName => {
            dropZone.addEventListener(evtName, (e) => {
                e.preventDefault();
                e.stopPropagation();
                dropZone.classList.remove('dragover');
            });
        });

        dropZone.addEventListener('drop', (e) => {
            const dt = e.dataTransfer;
            const files = dt && dt.files;
            if (files && files.length > 0) {
                handleFile(files[0]);
            }
        });

        // Build tree lazily - only immediate children, not recursively
        function buildTreeLazy(obj, name = "root", parentPath = []) {
            let label = name;
            const nodeType = Array.isArray(obj) ? 'array' : (obj === null ? 'null' : typeof obj);
            if (obj && typeof obj === 'object' && !Array.isArray(obj)) {
                if (obj.type) label += ` (${obj.type})`;
                else label += ` (${nodeType})`;
                if (obj.description) label += ` - ${obj.description}`;
            } else {
                label += ` (${nodeType})`;
            }
            
            const node = { 
                name: label, 
                children: null, // null means not yet built
                _children: null, // null means not yet built
                hasChildren: false,
                objData: obj, // Store original object data for lazy loading
                path: [...parentPath, name] // Store path to rebuild children
            };

            // Check if this node has children (but don't build them yet)
            if (obj && typeof obj === 'object' && obj !== null) {
                if (Array.isArray(obj)) {
                    // Arrays have children if they have items
                    node.hasChildren = obj.length > 0;
                } else {
                    // For objects, check JSON Schema format first, then regular object keys
                    if (obj.properties && Object.keys(obj.properties).length > 0) {
                        node.hasChildren = true;
                    } else if (obj.items && typeof obj.items === 'object') {
                        node.hasChildren = true;
                    } else {
                        // Regular JSON object - check if it has any keys
                        const keys = Object.keys(obj);
                        node.hasChildren = keys.length > 0;
                    }
                }
            }
            
            return node;
        }

        // Build children for a node on-demand
        function buildChildrenForNode(node) {
            if (node.children !== null) return; // Already built
            
            const obj = node.objData;
            if (!obj || typeof obj !== 'object' || obj === null) return;
            
            const children = [];
            
            // Handle JSON Schema format
            if (obj.properties) {
                for (const key in obj.properties) {
                    children.push(buildTreeLazy(obj.properties[key], key, node.path));
                }
            }
            if (obj.items && typeof obj.items === 'object') {
                children.push(buildTreeLazy(obj.items, "items", node.path));
            }
            
            // Handle regular JSON objects and arrays
            if (Array.isArray(obj)) {
                // For arrays, create index-based children
                obj.forEach((item, index) => {
                    children.push(buildTreeLazy(item, `[${index}]`, node.path));
                });
            } else {
                // For regular objects, iterate over all keys
                // Only if we haven't already processed properties/items
                if (!obj.properties && !obj.items) {
                    for (const key in obj) {
                        // Skip special JSON Schema keys that we've already handled
                        if (key !== 'type' && key !== 'description' && key !== 'required' && 
                            key !== 'enum' && key !== 'default' && key !== 'title') {
                            children.push(buildTreeLazy(obj[key], key, node.path));
                        }
                    }
                }
            }
            
            node.children = children.length > 0 ? children : null;
            node._children = node.children;
        }

        // Helper to convert our lazy node structure to D3 hierarchy format
        function getNodeData(d3Node) {
            if (d3Node.data) {
                return d3Node.data;
            }
            return d3Node;
        }

        // Store root data for rebuilding hierarchy
        let rootDataStore = null;

        // Find original data by traversing path (defined outside renderTree so it's available everywhere)
        function findOriginalByPath(path) {
            if (!path || path.length === 0) return rootDataStore;
            if (!rootDataStore) return null;
            let current = rootDataStore;
            for (let i = 1; i < path.length; i++) {
                const pathKey = path[i];
                // Try to find by matching the name (which includes the key)
                let found = null;
                if (current.children) {
                    found = current.children.find(c => {
                        // Extract the key from the name (before the first space or parenthesis)
                        const nameKey = c.name.split(' ')[0].split('(')[0];
                        return nameKey === pathKey || c.name.startsWith(pathKey + ' ');
                    });
                }
                if (!found && current._children) {
                    found = current._children.find(c => {
                        const nameKey = c.name.split(' ')[0].split('(')[0];
                        return nameKey === pathKey || c.name.startsWith(pathKey + ' ');
                    });
                }
                if (!found) return null;
                current = found;
            }
            return current;
        }

        // Cache for faster lookups
        let nodeCache = new Map();

        function renderTree(data) {
            g.selectAll("*").remove(); // Clear previous tree
            rootDataStore = data;
            nodeCache.clear(); // Clear cache on new tree
            nodeCache.set('root', data); // Cache root
            
            // Build children for root only initially (so root's children are visible)
            if (data.hasChildren && data.children === null) {
                buildChildrenForNode(data);
                // Cache root's children
                if (data.children) {
                    data.children.forEach(child => {
                        nodeCache.set(child.path.join('/'), child);
                    });
                }
            }
            
            let root = d3.hierarchy(rootDataStore);
            // With nodeSize, we need to position root differently
            // Root will be at the left, and tree expands to the right
            root.x0 = 1000; // Center vertically in the larger SVG
            root.y0 = 0; // Start at the left

            // Mark root's children as collapsed in data structure (but they're visible in D3)
            if (root.children && rootDataStore.children) {
                rootDataStore.children.forEach(child => {
                    child.children = null;
                    child._children = null; // Not built yet
                });
            }
            update(root);

            function collapse(d) {
                if (d.children) {
                    // Store in data for persistence
                    if (d.data) {
                        d.data._children = d.data.children;
                        d.data.children = null;
                    }
                    d._children = d.children;
                    d._children.forEach(collapse);
                    d.children = null;
                }
            }


            function update(source) {
                // Optimized: Only rebuild if structure changed, otherwise reuse existing hierarchy
                let root;
                if (source && source.data && source.data.path) {
                    // We're updating from a specific node, rebuild from root
                    root = rebuildHierarchy();
                } else {
                    // Initial render or full rebuild
                    root = rebuildHierarchy();
                }
                
                function rebuildHierarchy() {
                    // Helper to convert data structure for D3 (handles lazy loading)
                    function dataForD3(nodeData) {
                        if (!nodeData) return null;
                        const result = {
                            name: nodeData.name,
                            path: nodeData.path,
                            objData: nodeData.objData,
                            hasChildren: nodeData.hasChildren
                        };
                        
                        // If expanded, use children; if collapsed, use _children; if not built, use empty
                        if (nodeData.children !== null) {
                            // Expanded
                            result.children = nodeData.children.map(dataForD3);
                        } else if (nodeData._children !== null) {
                            // Collapsed but built - D3 needs children to know structure, but we'll mark as _children
                            result.children = nodeData._children.map(dataForD3);
                        } else if (nodeData.hasChildren) {
                            // Not yet built - empty so D3 knows it exists
                            result.children = [];
                        }
                        return result;
                    }
                    
                    // Rebuild hierarchy from root data
                    const d3Data = dataForD3(rootDataStore);
                    let newRoot = d3.hierarchy(d3Data);
                    newRoot.x0 = source && source.x0 ? source.x0 : 1000;
                    newRoot.y0 = source && source.y0 ? source.y0 : 0;
                    
                    // Fast sync: only sync what's visible
                    function syncWithOriginal(d3Node) {
                        if (!d3Node.data || !d3Node.data.path) return;
                        
                        // Use cache for faster lookups
                        const pathKey = d3Node.data.path.join('/');
                        let originalData = nodeCache.get(pathKey);
                        if (!originalData) {
                            originalData = findOriginalByPath(d3Node.data.path);
                            if (originalData) nodeCache.set(pathKey, originalData);
                        }
                        
                        if (!originalData) return;
                        
                        // Link original data
                        d3Node.originalData = originalData;
                        
                        // If original is collapsed, collapse D3 node
                        if (originalData.children === null && originalData._children !== null) {
                            d3Node._children = d3Node.children;
                            d3Node.children = null;
                        }
                        
                        // Only sync visible children (not _children) for performance
                        if (d3Node.children) {
                            d3Node.children.forEach(syncWithOriginal);
                        }
                    }
                    syncWithOriginal(newRoot);
                    return newRoot;
                }
                
                root = rebuildHierarchy();

                treeLayout(root);

                const nodes = root.descendants();
                const links = root.links();

                // Adjust positioning - nodeSize handles spacing, but we may need to adjust
                // The tree layout automatically calculates positions with nodeSize

                const node = g.selectAll(".node")
                    .data(nodes, d => d.id || (d.id = d.data.path.join('/')));

                const nodeEnter = node.enter().append("g")
                    .attr("class", "node")
                    .attr("transform", d => `translate(${source.y0},${source.x0})`)
                    .on("click", (event, d) => {
                        event.stopPropagation();
                        
                        const originalData = d.originalData || (d.data && findOriginalByPath(d.data.path));
                        
                        if (!originalData) return;
                        
                        // Collapse this node if it's currently expanded
                        if (d.children && d.children.length > 0) {
                            originalData.children = null;
                            if (d.children) {
                                originalData._children = d.children.map(c => {
                                    const childData = c.originalData || (c.data && findOriginalByPath(c.data.path));
                                    return childData || c.data;
                                }).filter(Boolean);
                            }
                            collapse(d);
                        } else if (originalData.hasChildren) {
                            // Before expanding this node, collapse its siblings to reduce clutter
                            if (d.parent && d.parent.children) {
                                d.parent.children.forEach(sibling => {
                                    if (sibling !== d && sibling.children && sibling.children.length > 0) {
                                        const siblingData = sibling.originalData || (sibling.data && findOriginalByPath(sibling.data.path));
                                        if (siblingData) {
                                            siblingData.children = null;
                                            if (sibling.children) {
                                                siblingData._children = sibling.children.map(c => {
                                                    const childData = c.originalData || (c.data && findOriginalByPath(c.data.path));
                                                    return childData || c.data;
                                                }).filter(Boolean);
                                            }
                                        }
                                        collapse(sibling);
                                    }
                                });
                            }
                            
                            // Build children lazily if not already built
                            if (originalData.children === null && originalData._children === null) {
                                buildChildrenForNode(originalData);
                                if (originalData.children) {
                                    originalData._children = originalData.children;
                                    // Cache the newly built children for faster lookups
                                    originalData.children.forEach(child => {
                                        nodeCache.set(child.path.join('/'), child);
                                    });
                                }
                            }
                            
                            // Expand this node
                            if (originalData._children && originalData._children.length > 0) {
                                originalData.children = originalData._children;
                                originalData._children = null;
                            }
                        }
                        update(d);
                    });

                nodeEnter.append("circle")
                    .attr("r", 1e-6)
                    .style("fill", d => {
                        const orig = d.originalData || (d.data && findOriginalByPath(d.data.path));
                        return (orig && orig.hasChildren && orig.children === null && orig._children === null) || d._children ? "#69b3a2" : "#fff";
                    });

                nodeEnter.append("text")
                    .attr("dy", ".35em")
                    .attr("x", d => d.children || d._children ? -15 : 15)
                    .style("text-anchor", d => d.children || d._children ? "end" : "start")
                    .style("font-size", "11px")
                    .text(d => d.data.name);

                const nodeUpdate = nodeEnter.merge(node);

                nodeUpdate.transition()
                    .duration(200) // Faster transition
                    .attr("transform", d => `translate(${d.y},${d.x})`);

                nodeUpdate.select("circle")
                    .attr("r", 6)
                    .attr("class", d => {
                        const orig = d.originalData || (d.data && findOriginalByPath(d.data.path));
                        return (orig && orig.hasChildren && orig.children === null && orig._children === null) || d._children ? "expandable" : "";
                    })
                    .style("fill", d => {
                        const orig = d.originalData || (d.data && findOriginalByPath(d.data.path));
                        return (orig && orig.hasChildren && orig.children === null && orig._children === null) || d._children ? "#667eea" : "#fff";
                    });

                // Remove nodes that are no longer in the data (when collapsed)
                const nodeExit = node.exit().transition()
                    .duration(150) // Faster removal
                    .attr("transform", d => `translate(${source.y},${source.x})`)
                    .remove();

                nodeExit.select("circle").attr("r", 1e-6);
                nodeExit.select("text").style("fill-opacity", 1e-6);

                const link = g.selectAll(".link")
                    .data(links, d => d.target.id);

                const linkEnter = link.enter().insert("path", "g")
                    .attr("class", "link")
                    .attr("d", d => {
                        const o = { x: source.x0, y: source.y0 };
                        return d3.linkHorizontal()({ source: o, target: o });
                    });

                const linkUpdate = linkEnter.merge(link);

                linkUpdate.transition()
                    .duration(200) // Faster transition
                    .attr("d", d3.linkHorizontal()
                        .x(d => d.y)
                        .y(d => d.x));

                // Remove links that are no longer in the data (when collapsed)
                link.exit().transition()
                    .duration(150) // Faster removal
                    .attr("d", d => {
                        const o = { x: source.x, y: source.y };
                        return d3.linkHorizontal()({ source: o, target: o });
                    })
                    .remove();

                nodes.forEach(d => {
                    d.x0 = d.x;
                    d.y0 = d.y;
                });
            }
        }
    </script>
</body>
</html>
